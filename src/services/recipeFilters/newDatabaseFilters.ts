
import { CombinedRecipe } from '@/types/newDatabase';
import { UserPreference } from '@/services/preferenceFilters';

export const getRecipesByMealTypeNew = (
  recipes: CombinedRecipe[],
  mealTypeRecipes: Record<string, string[]>,
  mealType: string,
  userPreferences: UserPreference[] = []
): CombinedRecipe[] => {
  console.log('üîç Receptek keres√©se kombin√°lt m√≥dszerrel:', { 
    mealType, 
    totalRecipes: recipes.length,
    availableMealTypes: Object.keys(mealTypeRecipes)
  });
  
  const mealTypeRecipeNames = mealTypeRecipes[mealType] || [];
  console.log(`üìã ${mealType} t√≠pus√∫ receptek nevei:`, mealTypeRecipeNames.length, 'db');
  
  if (mealTypeRecipeNames.length === 0) {
    console.warn(`‚ö†Ô∏è Nincs ${mealType} t√≠pus√∫ recept a mealTypeRecipes-ben`);
    
    // Fallback: keress√ºnk a recept nevekben k√∂zvetlen√ºl
    const directMatches = recipes.filter(recipe => {
      const recipeName = recipe.n√©v.toLowerCase();
      const mealTypeLower = mealType.toLowerCase();
      
      // Egyszer≈± sz√∂veg alap√∫ keres√©s
      const hasDirectMatch = recipeName.includes(mealTypeLower) ||
                           (mealTypeLower === 'reggeli' && (recipeName.includes('reggeli') || recipeName.includes('breakfast'))) ||
                           (mealTypeLower === 'eb√©d' && (recipeName.includes('eb√©d') || recipeName.includes('lunch'))) ||
                           (mealTypeLower === 'vacsora' && (recipeName.includes('vacsora') || recipeName.includes('dinner'))) ||
                           (mealTypeLower === 't√≠z√≥rai' && (recipeName.includes('t√≠z√≥rai') || recipeName.includes('snack'))) ||
                           (mealTypeLower === 'uzsonna' && (recipeName.includes('uzsonna') || recipeName.includes('snack')));
      
      return hasDirectMatch;
    });
    
    console.log(`üîç Fallback keres√©s eredm√©nye: ${directMatches.length} recept`);
    
    if (directMatches.length > 0) {
      return applyUserPreferences(directMatches, userPreferences);
    }
    
    // Ha m√©g mindig nincs tal√°lat, adjunk vissza random recepteket
    console.log('üé≤ Nincs specifikus tal√°lat, random receptek visszaad√°sa...');
    const randomRecipes = recipes.slice(0, Math.min(5, recipes.length));
    return applyUserPreferences(randomRecipes, userPreferences);
  }

  // Norm√°l sz≈±r√©s a meal type alapj√°n
  const filteredRecipes = recipes.filter(recipe => {
    const recipeName = recipe.n√©v.toLowerCase();
    const hasMatch = mealTypeRecipeNames.some(mealRecipeName => {
      const mealRecipeNameLower = mealRecipeName.toLowerCase();
      return recipeName.includes(mealRecipeNameLower) ||
             mealRecipeNameLower.includes(recipeName) ||
             recipeName === mealRecipeNameLower;
    });
    
    return hasMatch;
  });

  console.log(`‚úÖ Tal√°lt receptek ${mealType} t√≠pushoz:`, filteredRecipes.length);
  
  return applyUserPreferences(filteredRecipes, userPreferences);
};

const applyUserPreferences = (recipes: CombinedRecipe[], userPreferences: UserPreference[]): CombinedRecipe[] => {
  if (userPreferences.length === 0) {
    return recipes;
  }

  const preferenceFilteredRecipes = recipes.filter(recipe => {
    // Ellen≈ërizz√ºk, hogy a recept tartalmaz-e dislike-olt alapanyagot
    const hasDislikedIngredient = recipe.hozz√°val√≥k.some(ingredient => {
      return userPreferences.some(pref => 
        pref.preference === 'dislike' && 
        ingredient.toLowerCase().includes(pref.ingredient.toLowerCase())
      );
    });
    
    if (hasDislikedIngredient) {
      console.log(`‚ùå "${recipe.n√©v}" kisz≈±rve preferenci√°k miatt`);
    }
    
    return !hasDislikedIngredient;
  });
  
  console.log(`üéØ Preferenci√°k alkalmaz√°sa ut√°n: ${preferenceFilteredRecipes.length} recept`);
  return preferenceFilteredRecipes;
};

export const filterRecipesByMultipleIngredientsNew = (
  recipes: CombinedRecipe[],
  requiredIngredients: string[]
): CombinedRecipe[] => {
  console.log('üîç T√∂bb alapanyag alapj√°n sz≈±r√©s (kombin√°lt m√≥dszer):', requiredIngredients);
  
  if (requiredIngredients.length === 0) {
    console.log('‚ö†Ô∏è Nincs megadva alapanyag, minden recept visszak√ºld√©se');
    return recipes;
  }
  
  return recipes.filter(recipe => {
    const recipeIngredients = recipe.hozz√°val√≥k.map(ing => ing.toLowerCase());
    
    // Minden sz√ºks√©ges alapanyagnak szerepelnie kell a receptben
    const hasAllIngredients = requiredIngredients.every(requiredIngredient => {
      const requiredLower = requiredIngredient.toLowerCase();
      const hasIngredient = recipeIngredients.some(recipeIngredient => 
        recipeIngredient.includes(requiredLower) ||
        requiredLower.includes(recipeIngredient.split(' ').pop() || '') // Utols√≥ sz√≥ keres√©se
      );
      
      if (!hasIngredient) {
        console.log(`‚ùå "${recipe.n√©v}" nem tartalmazza: ${requiredIngredient}`);
      }
      
      return hasIngredient;
    });
    
    if (hasAllIngredients) {
      console.log(`‚úÖ "${recipe.n√©v}" tartalmazza az √∂sszes sz√ºks√©ges alapanyagot`);
    }
    
    return hasAllIngredients;
  });
};

export const getRecipesByCategoryNew = (
  recipes: CombinedRecipe[],
  mealTypeRecipes: Record<string, string[]>,
  categories: Record<string, string[]>,
  category: string,
  ingredient?: string,
  mealType?: string,
  userPreferences: UserPreference[] = []
): CombinedRecipe[] => {
  console.log('üîç Receptek keres√©se kateg√≥ria alapj√°n (kombin√°lt m√≥dszer):', { 
    category, 
    ingredient, 
    mealType,
    totalRecipes: recipes.length
  });
  
  let filteredRecipes = [...recipes];
  
  // Sz≈±r√©s meal type alapj√°n ha meg van adva
  if (mealType) {
    console.log(`üéØ Sz≈±r√©s meal type alapj√°n: ${mealType}`);
    filteredRecipes = getRecipesByMealTypeNew(filteredRecipes, mealTypeRecipes, mealType, userPreferences);
  }
  
  // Sz≈±r√©s alapanyag alapj√°n ha meg van adva
  if (ingredient) {
    console.log(`üéØ Sz≈±r√©s alapanyag alapj√°n: ${ingredient}`);
    filteredRecipes = filteredRecipes.filter(recipe => {
      const hasIngredient = recipe.hozz√°val√≥k.some(recipeIngredient => {
        const recipeIngLower = recipeIngredient.toLowerCase();
        const ingredientLower = ingredient.toLowerCase();
        return recipeIngLower.includes(ingredientLower) ||
               ingredientLower.includes(recipeIngredient.split(' ').pop()?.toLowerCase() || '');
      });
      
      if (hasIngredient) {
        console.log(`‚úÖ "${recipe.n√©v}" tartalmazza: ${ingredient}`);
      }
      
      return hasIngredient;
    });
  }
  
  console.log(`‚úÖ Kateg√≥ria sz≈±r√©s eredm√©nye: ${filteredRecipes.length} recept`);
  return filteredRecipes;
};
